%!TEX root = ../main.tex

\section{TimSort}
\spacing{1.5}

TimSort - это гибридный алгоритм, который сочетает в себе слияние
двух миров, стратегию "разделяй и властвуй"  MergeSort() и эффективность
InsertionSort() для небольших наборов данных.

Алгоритм имеет сложность {} и является одним из лучших алгоритмов для
сортировки реальных наборов данных, поскольку обычно имеются уже упорядоченные
наборы данных.

Основной причиной его эффективности является его принцип разделения массива
на блоки, известные как Runs, где если количество элементов в массиве меньше
Run просто выполняет insertionsort(), а если больше, то разделяет их для
сортировки данных, а затем соединяет их вместе.

\subsection{Code TimSort}

\subsubsection{InsertionSort(new)}
\spacing{1.5}

Для правильного функционирования этого алгоритма необходимо сначала
внести небольшое изменение в наш алгоритм InsertionSort(), поскольку он будет
постоянно изменять значения начального и конечного пределов. Так и будет:

\begin{enumerate}
  \item \textit{InsertionSort.py}
    \singlespace
    \lstinputlisting[language=Python]{code/insertionfortim.py}
\end{enumerate}

\subsubsection{TimSort}
\spacing{1.5}

Для повышения производительности сортировки была создана функция для
поиска наилучшего числа MinRun, поскольку значительную часть
скорости составляет выбор наилучшего способа разбиения массива.

Затем, рекурсивно используя сортировку InsertionSort() для каждого Run,
большая часть данных сортируется и с помощью функции Merge сортировки
MergeSort() объединяется вместе, чтобы получить исходный сортируемый массив.
Так и будет:

\begin{enumerate}
  \item \textit{TimSort.py}
  \singlespace
  \lstinputlisting[language=Python]{code/timsort.py}
\end{enumerate}
